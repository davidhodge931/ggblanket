---
title: "ggblanket"
author: "David Hodge"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ggblanket}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.5,
  out.width = "70%",
  dpi = 300)
```

## Overview

ggblanket is a package of ggplot2 wrapper functions.

The primary objective is to **simplify ggplot2 visualisation**.

Secondary objectives relate to:

* Design: produce well-designed visualisation by default
* Scope: cover the most useful 80% of what ggplot2 does
* Alignment: use conventions generally aligned with ggplot2. 

## How it works
 
1.  Over thirty `gg_*` wrapper functions
2.  A single `col` argument to colour and fill by a variable
3.  A `col_pal` argument to customise colours
4.  A `facet` argument to facet by a variable
5.  An additional `facet2` argument to facet by a 2nd variable
6.  Conversion of unspecified `titles` to sentence case
7.  Ability to customise by prefixed arguments 
8.  Ability to customise the `theme`
9.  Access to other `geom_*` arguments via ...
10. Pretty continuous positional scales
11. Ability to add multiple `geom_*` layers
12. Other key differences to ggplot2

```{r setup}
library(ggblanket)
library(ggplot2)
library(patchwork)
library(dplyr)
library(stringr)
library(tidyr)
library(palmerpenguins)
```
 
### 1. Over thirty `gg_*` wrapper functions

Each `gg_*` function wraps a ggplot2 `ggplot(aes(...))` function with the applicable ggplot2 `geom_*()` function. Each `gg_*` function is named after the `geom_*` function they wrap. 

```{r}
penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
  )
```

### 2. A single `col` argument to colour and fill by a variable

The colour and fill aesthetics of ggplot2 are merged into a single concept represented by the `col` argument. This argument means that everything should be coloured according to it, i.e. all points, lines and polygon interiors. 

```{r}
penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g, 
    col = species,
  )
```


```{r}
penguins |>
  drop_na(sex) |>
  mutate(across(sex, \(x) str_to_sentence(x))) |>
  gg_bar(
    y = species, 
    col = sex,
    width = 0.75,
    position = position_dodge(preserve = "single"),
  )
```

### 3. A `col_pal` argument to customise colours

The `col_pal` argument is used to customise the colours of the geom. A user can provide a vector of colours to this argument. It can be named or not. It works in a consistent way - regardless of whether a `col` aesthetic is added or not. A named palette can be used to make individual colours stick to particular values. 

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_jitter(
    x = species, 
    y = body_mass_g, 
    col_pal = "#FF7043",
  )
```

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_density(
    x = flipper_length_mm, 
    col = species, 
    col_pal = c("#0095A8", "#112E51", "#FF7043"),
  )
```

### 4. A `facet` argument to facet by a variable

Faceting is treated as if it were an aesthetic. Users just provide an unquoted variable to facet by. If a single facet (or facet2) variable is provided, it'll default to a "wrap" layout. But users can change this with a `facet_layout = "grid"` argument.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_violin(
    x = sex,
    y = body_mass_g,
    facet = species
  )
```

### 5. An additional `facet2` argument to facet by a 2nd variable

A `facet2` argument is also provided for extra functionality and flexibility. If both `facet`and `facet2` variables are provided, then it'll default to a "grid" layout of `facet` by `facet2`. But users can change this with a `facet_layout = "wrap"` argument.

```{r, fig.asp=0.75}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_histogram(
    x = flipper_length_mm,
    facet = species,
    facet2 = sex,
  )
```

### 6.  Conversion of unspecified titles to sentence case

Unspecified `x`, `y`, and `col` titles are converted to sentence case with snakecase::to_sentence. All titles can be manually changed using the `*_title` arguments. The default conversion is intended to make titles sometimes able to be left as is. Use `*_title = ""` to remove a title. 

```{r, fig.asp=0.6}
diamonds |>
  gg_hex(
    x = carat,
    y = price,
    y_limits = c(0, 20000),
    coord = ggplot2::coord_cartesian(clip = "on"), 
  )
```

### 7.  Ability to customise by prefixed arguments 

Prefixed arguments are available to customise titles, scales, guides, and faceting. These prefixes organise the adjustments by whether they relate to `x`, `y`, `col` or `facet`. 

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_jitter(
    x = species,
    y = body_mass_g,
    col = flipper_length_mm,
    x_labels = \(x) str_sub(x, 1, 1),
    y_expand_limits = 0,
    y_breaks = scales::breaks_width(1500), 
    y_labels = scales::label_number(big.mark = " "), 
    y_expand = expansion(mult = c(0, 0.05)),
    y_transform = "sqrt",
    y_title = "Body mass (g)",
  )
```

These prefixed arguments work nicely with the Rstudio autocomplete, if users:

* ensure their settings support the use of tab for autocompletions and multi-line autocompletions (i.e. Tools - Global Options - Code - Completion)
* pipe data into the `gg_*` functions.

With these settings and use of the pipe, users can type the prefix, and then use the tab and arrow keys to assist in finding and selecting the arguments they need to adjust.

```{r, echo = FALSE,   fig.width = 3, fig.asp = 2}
knitr::include_graphics("autocomplete_y.png", dpi = 300)
```

### 8.  Ability to customise the `theme`

Users can use the `theme` argument in a `gg_*` function for the theme of a plot. Alternatively, users can set the theme globally using the `ggplot2::theme_set` function, such that all subsequent plots will use this by default. 

ggblanket provides two complete families of ggplot2 theme functions called `dark_mode_*` (the default) and `dark_mode_*`. The suffix refers to the placement of the legend with `rt` referring to right top, `r` right centre, `b` being bottom and `t` being top. The default is `dark_mode_rt()`.

The first argument is the `base_size`. It defaults to 11. This changes the size of the text to this with the title is 10% higher and the caption is 10% lower. 

Note that `theme_set(theme_grey())` resets the set theme for ggplot2 code to theme_grey and for ggblanket `gg_*` functions to `dark_mode_rt()`. If you want ggblanket `gg_*` functions to default to using `theme_grey()`, then you must modify the base_size slightly (e.g. `theme_set(theme_grey(11.01))`).

```{r, fig.asp=0.66}
# theme_set(dark_mode_rt())

penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex,
    col_title = "",
    title = "Penguins body mass by flipper length",
    subtitle = "Palmer Archipelago, Antarctica",
    caption = "Source: Gorman, 2020", 
    theme = dark_mode_t(),
  )
```

The `gg_*` function will by default adjust what gridlines are present - and remove the ones that it guesses are not required. You can adjust this using the *_gridlines arguments. Subsequently, it is recommended that themes with gridlines in both x and y directions are used with ggblanket.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_jitter(
    x = flipper_length_mm,
    y = sex,
    col = sex, 
    theme = theme_grey(),
  )
```

### 9. Access to other `geom_*` arguments via `...`

The `...` argument provides accesss to all other arguments in the `geom_*` function. Common arguments from `...` to add are `size`, `linewidth` and `width`.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  drop_na(sex) |> 
  gg_smooth(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex, 
    se = TRUE,
    linewidth = 0.5,
    level = 0.99,
  ) 
```

### 10. Pretty continuous positional scales

Where the orientation is normal (i.e. vertical):

-   Default x scale limits and expanding are as per ggplot2 defaults
-   Default continuous y scale limits (that are non-transformed) start and end on a break with zero expanding
-   Default categorical (or numeric transformed) y scale limits and expanding are as per ggplot2 defaults
-   Default removal of vertical gridlines 

It does the opposite where the orientation is horizontal. 


Sometimes with small plots or faceted plots etc, the default approach is not optimal as it can waste space. In these cases, users can: 
* set limits to the range of the data using `*_limits = c(NA, NA)`
* and add more frequent breaks (e.g. `*_breaks = scales::breaks_pretty(10)`), and use the `str_keep_seq` helper function to only keep every 2nd (or nth) label. 

```{r}
penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex,
    x_breaks = scales::breaks_pretty(10),
    x_labels = \(x) str_keep_seq(x),
    y_limits = c(NA, NA),
  )
```

### 11. Ability to add multiple `geom\_\*` layers

Users can make plots with multiple layers with ggblanket by adding on `ggplot2::geom_*` layers. 

The `gg_*` function puts the aesthetic variables (i.e. `x`, `y`, `col`) within the wrapped `ggplot` function. Therefore, these aesthetics will inherit to any subsequent layers added.
`facet` and `facet2` will likewise inherit - as will `data`, `coord` and `theme`.


The `gg_*` function _should_ be appropriate to be the bottom layer of the plot. This is because the geoms will plot in order. 

```{r}
ggplot2::economics |>
  slice_min(order_by = date, n = 10) |> 
  gg_line(
    x = date,
    y = unemploy,
    col_pal = pal_guardian[1],
    x_title = "",
    y_title = "Unemployment",
    y_expand_limits = 0,
    linewidth = 1, 
    x_breaks = scales::breaks_width("3 months"),
    title = "gg_line + geom_point", 
  ) +
  geom_point(colour = pal_guardian[2])

```


```{r}
ggplot2::economics |>
  slice_min(order_by = date, n = 10) |> 
  gg_point(
    x = date,
    y = unemploy,
    col_pal = pal_guardian[2],
    x_title = "",
    y_title = "Unemployment",
    y_expand_limits = 0,
    x_breaks = scales::breaks_width("3 months"),
    title = "gg_point + geom_line", 
  ) +
  geom_line(colour = pal_guardian[1], linewidth = 1)
```

All of the aesthetics required for the plot as a whole should generally be added into the `gg_*` function, including the `col` argument. If you do not want the first layer to have a colour and fill aesthetic, but you wish later layers to access this - use `gg_blank`. 

Use `*_expand_limits` or  `*_limits` to ensure the `gg_* function builds the limits appropriately for the plot as a whole.

```{r, fig.asp = 0.4}
penguins |>
  group_by(species) |>
  summarise(body_mass_g = mean(body_mass_g, na.rm = TRUE)) |>
  mutate(lower = body_mass_g * 0.95) |> 
  mutate(upper = body_mass_g * 1.2) %>%
  gg_col(
    x = body_mass_g,
    xmin = lower, 
    xmax = upper,
    y = species,
    col = species,
    width = 0.75,
    x_expand_limits = c(0, max(.$upper)),
    x_labels = \(x) x / 1000, 
    x_title = "Body mass kg", 
  ) +
  geom_errorbar(
    colour = "black",
    width = 0.1) 
```

```{r, fig.asp=0.4}
penguins |>
  group_by(species) |>
  summarise(body_mass_g = mean(body_mass_g, na.rm = TRUE)) |>
  mutate(lower = body_mass_g * 0.95) |> 
  mutate(upper = body_mass_g * 1.2) |> 
  gg_blank( 
    x = body_mass_g,
    y = species,
    col = species,
    xmin = lower, 
    xmax = upper,
    width = 0.75,
    x_expand_limits = 0,
    x_labels = \(x) x / 1000, 
    x_title = "Body mass kg",
  ) +
  geom_col(
    width = 0.75,
    colour = "#d3d3d3",#fix to constant
    fill = "#d3d3d3",#fix to constant
    alpha = 0.9) +
  geom_errorbar(width = 0.1) 

```

### 12. Other key differences to ggplot2

##### Unquoted variables only

ggblanket requires unquoted variables only for `x`, `y`, `col`, `facet`, `facet2` and  `alpha`. You cannot wrap these in a function. Instead you need to apply the function to the relevant variable in the data prior to plotting. For example, reordering or reversing a factor or dropping NAs. If you wish to use delayed evaluation or other aesthetics, you can do so via the `mapping` argument. 

```{r}
diamonds |>
  count(color) |>
  mutate(color = color |>
           forcats::fct_reorder(n) |>
           forcats::fct_rev()) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
  )
```

##### Unused factor levels kept

ggblanket keeps unused factor levels in the plot. If users wish to drop unused levels they should likewise do it in the data prior to plotting using `forcats::fct_drop`. 

```{r, fig.asp=0.4}
diamonds |> 
  count(color) |>
  filter(color %in% c("E", "G", "I")) |>
  mutate(color = forcats::fct_drop(color)) |> 
  gg_point(
    x = n,
    y = color,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
  )
```

##### Different `col_pal` and `alpha_pal` defaults

ggblanket uses different defaults for colouring. The default `pal` is:

* `#357BA2` or `viridis::mako(9)[5]` for no `col` variable
* `ggblanket::pal_guardian` for a discrete `col` variable with 4 or less levels (or unique values if a character). This palette is colourblind safe. 
* `scales::pal_hue` for a discrete `col` variable with 5 or more levels (or unique values if not ordered).
* `viridis::mako(20)` reversed for a continuous `col` variable
* `"#bebebe"` or `grey` for NA

ggblanket uses different `alpha_pal` defaults for the different `gg_*` functions. 

Polygons that generally overlap, or have key lines within them default to 0.5: `gg_density`, `gg_boxplot`, `gg_crossbar`, `gg_ribbon` and `gg_smooth`. Point or line based geoms use 1: `contour`, `density_2d`, `density2d`, `errorbar`, `line`, `linerange`, `point`, `pointrange`, `segment`, `step`, and `text`. Polygons that generally have no gap or overlap default to 1: `gg_bin_2d`, `gg_contour_filled`, `gg_density_2d_filled`, and `gg_hex`. `gg_label` defaults to 0.1. Other polygons default to 0.9: `gg_area`, `gg_bar`, `gg_col`, `gg_histogram`, `gg_polygon`, `gg_rect`, `gg_tile`, `gg_violin` and `gg_sf`. For all other contexts, alpha defaults to 0.9. 

##### Different `oob` & `clip` defaults

By default, ggblanket keeps values outside of the limits (`*_oob = scales::oob_keep`) in calculating the geoms and scales to plot. It also does _not_ clip anything outside the cartesian coordinate space by default (`coord = ggplot2::coord_cartesian(clip = "off"`)). 

ggplot2 by default drops values outside of the limits in calculating the geoms and scales to plot (`scales::oob_censor`), and clips anything outside the cartesian coordinate space (`coord = ggplot2::coord_cartesian(clip = "on"`)).

```{r, fig.asp=1}
p1 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    y_labels = \(x) str_keep_seq(x),
    title = "No x_limits set") +
  geom_vline(xintercept = c(lubridate::ymd("1985-01-01", "1995-01-01")),
             col = pal_guardian[1], 
             linetype = 3) +
  geom_point(col = pal_guardian[1], alpha = 0.05)

p2 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    y_labels = \(x) str_keep_seq(x),
    title = "x_limits set") +
  geom_point(col = pal_guardian[1], alpha = 0.1)

p3 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    y_labels = \(x) str_keep_seq(x),
    coord = coord_cartesian(clip = "on"), 
    title = "x_limits set & cartesian space clipped") +
  geom_point(col = pal_guardian[1], alpha = 0.1)

p4 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    x_oob = scales::oob_censor,
    y_labels = \(x) str_keep_seq(x),
    title = "x_limits set & x_oob censored") +
  geom_point(col = pal_guardian[1], alpha = 0.1)

p5 <- economics |> 
  filter(between(date, lubridate::ymd("1985-01-01"), lubridate::ymd("1995-01-01"))) |> 
  gg_smooth(
    x = date, 
    y = unemploy,
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    y_labels = \(x) str_keep_seq(x),
    title = "x data filtered") +
  geom_point(col = pal_guardian[1], alpha = 0.1)

# p1 / (p2 + p3) / (p4 + p5) 
```

##### Computational speed is sacrificed

ggblanket is _much_ slower than ggplot2 in computational speed.  

```{r}
bench::mark({
  penguins |> 
    gg_point(
      x = flipper_length_mm, 
      y = body_mass_g, 
      col = species,
    )
}, iterations = 10)
```

```{r}
bench::mark({
  penguins |>
    ggplot() +
    geom_point(aes(x = flipper_length_mm, y = body_mass_g, colour = species)) 
}, iterations = 10)
```

##### Other minor stuff

* `*_title` is equivalent to `ggplot2::labs(* = ...)` or `ggplot2::scale_*(name = ...)`.
* Logical variables are reversed, so that `TRUE` always comes before `FALSE`.

## Further information 

See the ggblanket [website](https://davidhodge931.github.io/ggblanket/index.html) for further information, including [articles](https://davidhodge931.github.io/ggblanket/articles/) and [function reference](https://davidhodge931.github.io/ggblanket/reference/index.html).
