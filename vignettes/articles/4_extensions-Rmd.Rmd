---
title: "Extensions"
author: "David Hodge"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "70%",
  dpi = 300
  )
```


## Overview

This article will demonstrate some fantastic ggplot2 extension packages. 

```{r setup}
library(dplyr)
library(stringr)
library(ggplot2)
library(ggblanket)
library(patchwork)

penguins2 <- palmerpenguins::penguins |>
  mutate(sex = str_to_sentence(sex)) |>
  tidyr::drop_na(sex)
```

#### patchwork

The patchwork package enables plots to be patched together. 

A convenient hack to add a centred non-bold title in a non-faceted plot is to add a `facet_wrap` layer with a character string for the `facets` argument. 

```{r, fig.asp=0.9}
p1 <- mtcars |> 
  gg_point(x = mpg, 
           y = disp,
           y_labels = \(x) str_keep_seq(x)) +
  facet_wrap(~"Plot 1")

p2 <- mtcars |> 
  gg_boxplot(x = gear, 
             y = disp, 
             group = gear, 
             width = 0.5,
             y_labels = \(x) str_keep_seq(x)) +
  facet_wrap(~"Plot 2")

p3 <- mtcars |> 
  gg_smooth(x = disp, 
            y = qsec, 
            x_breaks = scales::breaks_pretty(4)) +
  facet_wrap(~"Plot 3")
```

#### ggbeeswarm

The ggbeeswarm package can be used to create scatter plots that avoid overlapping points.

```{r}
penguins2 |> 
  gg_blank(x = species, 
           y = body_mass_g) + 
  ggbeeswarm::geom_quasirandom(colour = pal_blue)
```

#### ggblend
 
The ggblend package provides blending of colours. Note you must use a graphics device that supports blending.
 
```{r}
penguins2 |>
  gg_blank(
    x = flipper_length_mm,
    col = species,
    pal = RColorBrewer::brewer.pal(9, "Set1"),
    stat = "density") +
  geom_density(alpha = 0.5) |> ggblend::blend("multiply")
```

#### ggbump

The ggbump package can be used to create bump plots.

```{r}
df <- tibble(
  country = c("India", "India", "India", "Sweden", "Sweden", "Sweden", "Germany",
              "Germany", "Germany", "Finland", "Finland", "Finland"), 
  year = c(2011, 2012, 2013, 2011, 2012, 2013, 2011, 2012, 2013, 2011, 2012, 2013),
  value = c(492, 246, 246, 369, 123, 492, 246, 369, 123, 123, 492, 369)) |> 
  group_by(year) |>  
  mutate(rank = rank(value, ties.method = "random")) |> 
  ungroup()

df |> 
  gg_blank(x = year, 
           y = rank, 
           col = country, 
           label = country,
           x_expand = c(0.2, 0.2),
           x_breaks = scales::breaks_width(1),
           x_labels = \(x) x,
           y_trans = "reverse",
           y_expand = c(0.05, 0.05),
           y_breaks = scales::breaks_width(-1),
           y_gridlines = FALSE) +
  ggbump::geom_bump(linewidth = 2, smooth = 8) +
  geom_point(size = 4) +
  geom_text(data = df |> filter(year == min(year)),
            aes(x = year - 0.1), size = 3.53, hjust = 1) +
  geom_text(data = df |> filter(year == max(year)),
            aes(x = year + 0.1), size = 3.53, hjust = 0) +
  ggeasy::easy_remove_axes(which = "y", what = c("ticks", "line"))
```

#### ggdensity

The ggdensity package provides visualizations of density estimates.  

```{r}
iris |>
  mutate(Species = str_to_sentence(Species)) |> 
  gg_blank(
    x = Sepal.Width,
    y = Sepal.Length,
    col = Species,
    facet = Species,
    col_legend_place = "r", 
    col_title = "Species") + 
  ggdensity::geom_hdr(col = NA) +
  labs(alpha = "Probs")  
```

#### ggdist

The ggdist package enables the visualisation of uncertainty. The key to making this work with ggblanket is ensuring that `gg_blank` builds the distribution scale correctly. You can hack this by adding `*min` and `*max` aesthetics of a very low and very high quantile of the distributions. However, it might be easier to just use ggplot2 here. 

```{r}
library(distributional)

d <- data.frame(
  name = c("Gamma(2,1)", "Normal(5,1)", "Mixture"),
  dist = c(
    dist_gamma(2, 1),
    dist_normal(5, 1),
    dist_mixture(
      dist_gamma(2, 1), 
      dist_normal(5, 1), 
      weights = c(0.4, 0.6))
  )) 

d |>
  mutate(dist_min = quantile(dist, 0.001), 
         dist_max = quantile(dist, 0.999)) |> #to get scales functionally
  gg_blank(
    y = name, 
    xmin = dist_min, xmax = dist_max, #to get scales functionally
    y_expand = c(0.05, 0.05),
    y_title = "") +
  ggdist::stat_slabinterval(
    aes(dist = dist),
    colour = pal_blue,
    fill = scales::alpha(pal_blue, 0.5))
```

```{r}
d <- tibble(x = 1:10,
       sd = seq(1, 3, length.out = 10)) |>
  mutate(dist = distributional::dist_normal(x, sd)) 

d |>
  mutate(dist_min = quantile(dist, 0.05), 
         dist_max = quantile(dist, 0.95)) |> #to get scales functionally
  gg_blank(
    x = x,
    ymin = dist_min, ymax = dist_max) + #to get scales functionally
  ggdist::stat_lineribbon(aes(ydist = dist)) +
  scale_fill_brewer() +
  labs(fill = "Level")  
```

#### ggeasy

The ggeasy package provides a lot of support for easily modifying themes. Removing axes often is useful for maps. 

```{r}
penguins2 |>
  gg_jitter(
    x = species, 
    y = body_mass_g, 
    col = sex, 
    pal = c("#2596be", "#fc7c24"),
    col_legend_place = "t",
    col_title = "") +
  ggeasy::easy_remove_axes(which = "y", 
                           what = c("line", "ticks"))
```

#### ggforce

The ggforce package includes functions for annotating areas of points, and a geom for making a smoothed line graph using a b-spline.

```{r}
penguins2 |> 
  gg_point(x = flipper_length_mm, 
           y = body_mass_g, 
           col = species,
           coord = coord_cartesian(clip = "on")
  ) +
  ggforce::geom_mark_hull(alpha = 0.1, concavity = 5) 
```

```{r}
ggplot2::economics |>
  slice_head(n = 35) |> 
  gg_point( #or use gg_blank
    x = date,
    y = unemploy,
    alpha = 0.25,
    y_title = "Unemployment") +
  ggforce::geom_bspline(n = 1000, colour = pal_blue)
```

#### ggh4x

The ggh4x package includes enhanced facet functionality.

```{r}
iris |> 
  rename_with(\(x) snakecase::to_snake_case(x)) |> 
  mutate(across(species, \(x) stringr::str_to_sentence(x))) |> 
  mutate(size = if_else(species == "Setosa", "Short Leaves", "Long Leaves")) |> 
  gg_point(x = sepal_width, 
           y = sepal_length, 
           x_breaks = scales::breaks_pretty(n = 3)) +
  ggh4x::facet_nested(cols = vars(size, species), nest_line = TRUE, solo_line = TRUE) +
  theme(strip.text.x = element_text(margin = margin(t = 2.5, b = 5)))
```

#### gghighlight

The gghighlight package enables geoms or parts thereof to be highlighted. 

```{r}
penguins2 |>
  gg_point(x = flipper_length_mm,
           y = body_mass_g) +
  gghighlight::gghighlight(body_mass_g >= 5000)
```

The `gg_*` function builds the scale for the data that it thinks will be within the panel. Therefore in some situations, you may need to make adjustments, so that the scale builds correctly. An alternative approach is use `ggblank` to build the scale for the non-faceted data, and then add in `geom_histogram`, `facet_wrap` and `gghighlight` layers.  

```{r}
iris |>
  gg_histogram(
    x = Sepal.Length,
    col = Species,
    facet = Species,
    facet_labels = \(x) str_to_sentence(x),
    pal = rep(pal_blue, 3)
  ) +
  gghighlight::gghighlight() +
  scale_y_continuous(expand = c(0, 0))
```

#### ggnewscale

The ggnewscale package enables multiple colour scales.

```{r}
penguins2 |> 
  gg_blank(x = flipper_length_mm, 
           y = body_mass_g) + 
  geom_point(aes(x = flipper_length_mm, y = body_mass_g, colour = bill_length_mm), 
             data = penguins2 |> filter(species == "Gentoo")) +
  scale_color_viridis_c(option = "A", direction = -1) +  labs(colour = "Gentoo\nBill length (mm)") +
  ggnewscale::new_scale_colour() +
  geom_point(aes(x = flipper_length_mm, y = body_mass_g, colour = species), 
             data = penguins2 |> filter(species != "Gentoo")) +
  scale_color_manual(values = pal_discrete[c(1, 3)]) +
  labs(colour = "Species") 
```

#### ggpattern

The ggpattern package can be used to add patterns to geoms.

```{r}
library(ggpattern)

penguins2 |> 
  group_by(species, sex) |> 
  summarise(across(body_mass_g, \(x) mean(x))) |> 
  gg_blank(x = body_mass_g, 
           y = species,
           col = sex,
           position = "dodge",
           pal = c("#2596be", "#fc7c24"),
           x_include = 0) +
  geom_col_pattern(aes(pattern = sex), 
                   position = "dodge",
                   alpha = 0.9,
                   width = 0.75) +
  guides(pattern = guide_legend(reverse = TRUE)) + #same direction the col scale 
  labs(pattern = "Sex") #name same as the col_title 
```

#### ggpointdensity

The ggpointdensity package can be used to create a cross between a scatter plot and a 2D density plot.
 
```{r}
tibble(x = rnorm(7000, sd = 1),
       y = rnorm(7000, sd = 10)) |> 
  gg_blank(
    x = x,
    y = y, 
    col_title = "N neighbours") +
  ggpointdensity::geom_pointdensity() +
  scale_colour_viridis_c()
```

#### ggrepel

The ggrepel package can be used to neatly avoid overlapping labels. 

```{r}
mtcars |> 
  tibble::rownames_to_column("car") |>
  filter(wt > 2.75, wt < 3.45) |> 
  gg_point(x = wt, y = mpg) +
  ggrepel::geom_text_repel(aes(label = car), colour = "#2B6999", size = 3.53) 
```

#### ggridges

The ggridges package enables ridgeline plots. 

```{r}
ggridges::Catalan_elections |>
  rename_with(snakecase::to_snake_case) |> 
  mutate(year = factor(year)) |>
  gg_blank(
    x = percent, 
    y = year, 
    col = option,
    y_expand = c(0, 0), 
    col_title = "",
    col_legend_rev = TRUE, 
    pal = pal_discrete[c(3, 1)],
    x_limits = c(0, 100),
    coord = coord_cartesian(clip = "on")) +
  ggridges::geom_density_ridges(
    alpha = 0.8, 
    col = "white")
```

#### ggtext

The ggtext package enables plot text to use markdown syntax. The applicable markdown theme elements need to be added to the plot.

Note if you want to have some or all of a title not bold, then it's important to change the default theme have a plain title - as otherwise the `gg_theme` defaults to bold. 

```{r}
penguins2 |>
  gg_blank(
    x = flipper_length_mm, 
    y = body_mass_g,
    title = "**Bold** or _italics_ or <span style = 'color:red;'>red</span>",
    theme = light_mode(title_face = "plain")
    ) +
  theme(plot.title = ggtext::element_markdown())
```

```{r, fig.asp=0.75}
penguins2 |>
  gg_point(
    x = bill_length_mm,
    y = bill_depth_mm,
    col = species,
    facet = island,
    facet2 = sex,
    x_title = "**Bill length** (mm)", 
    y_title = "**Bill depth** (mm)",
    col_title = "**Species**",
    title = "***Pygoscelis*** **penguin** bill lengths and depths",
    subtitle = "<span style = 'color: #53B0AE ;'>**Adelie**</span>, 
       <span style = 'color:#A31414;'>**Chinstrap**</span>, 
       *and* <span style = 'color:#B2C615;'>**Gentoo**</span>", 
    x_labels = \(x) glue::glue("_{x}_"),
    y_labels = \(x) glue::glue("_{x}_"),
    col_labels = \(x) glue::glue("_{x}_"),
    facet_labels = \(x) glue::glue("_{x}_"),
    theme = light_mode(title_face = "plain")
  ) +
  theme(  
    plot.title = ggtext::element_markdown(),
    plot.subtitle = ggtext::element_markdown(),
    axis.title.x = ggtext::element_markdown(), 
    axis.title.y = ggtext::element_markdown(), 
    axis.text.x = ggtext::element_markdown(), 
    axis.text.y = ggtext::element_markdown(),
    legend.title = ggtext::element_markdown(),
    legend.text = ggtext::element_markdown(), 
    strip.text.x = ggtext::element_markdown(),
    strip.text.y = ggtext::element_markdown())
```

#### geomtextpath

The geomtextpath package enables curved text.

```{r, fig.asp=0.9}
library(geomtextpath)
p1 <- pressure |>
  gg_blank(x = temperature, y = pressure) +
  geom_textline(
    label = "Mercury vapor pressure increases with temperature",
    size = 3.53, vjust = -0.5, hjust = 0.9, color = pal_blue, linecolor = pal_blue)

p2 <- expand.grid(x = 1:nrow(volcano), y = 1:ncol(volcano)) |> 
  mutate(z = c(volcano)) |> 
  gg_contour_filled(x = x, 
           y = y, 
           z = z, 
           binwidth = 20, 
           x_limits = c(NA, NA),
           x_expand = c(0, 0),
           y_limits = c(NA, NA), 
           col_legend_place = "n") +
  geom_textcontour(aes(label = after_stat(level)), size = 2.5, straight = TRUE) +
  ggeasy::easy_remove_axes() 

p1 / p2
```

#### ggiraph

The ggiraph package enables interactive plots.

```{r}
p <- diamonds |>
  gg_blank(
    x = color,
    y_include = 0,
    stat = "count", 
    theme = light_mode(base_family = "arial", base_size = 9)) +
  ggiraph::geom_bar_interactive(
    aes(tooltip = after_stat(count), 
        data_id = color), 
    width = 0.75, 
    col = pal_blue, 
    fill = pal_blue, 
    alpha = 0.9)

ggiraph::girafe(
  ggobj = p, 
  height_svg = 3, 
  width_svg = 5,
  options = list(
    ggiraph::opts_sizing(rescale = TRUE, width = 0.7),
    ggiraph::opts_tooltip(use_fill = TRUE), 
    ggiraph::opts_hover(css = "stroke:black;stroke-width:1px;")))
```

#### plotly::ggplotly

The `plotly::ggplotly` function enables interactive plots. The `text` aesthetic can be used to customise tooltips. Alternatively, use `plotly::ggplotly(p, tooltip = c("x", "y", "fill"))` or `plotly::ggplotly(p)`. 

```{r, out.width=500, out.height=300}
p <- diamonds |>
  group_by(color) |>
  count(name = "count") |>
  mutate(text = glue::glue("Colour: {color}
                            Count: {count}")) |>
  gg_col(
    x = color,
    y = count,
    text = text,
    width = 0.75,
    theme = light_mode(base_family = "arial"))

plotly::ggplotly(p, tooltip = "text")
```
