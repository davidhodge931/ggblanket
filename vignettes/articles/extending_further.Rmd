---
title: "Extending further"
author: "David Hodge"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "70%",
  dpi = 300,
  dev.args = list(png = list(type = "cairo")),
  fig.retina = 2
  )
```

## Overview

To extend ggblanket further, users can:

1. Use the ggblank function
2. Work with non-default stat's
3. Use non-supported aesthetics
4. Use non-supported arguments
5. Use non-supported geoms
6. Modifying a part of the colouring 
7. Create custom wrapper functions
8. Visualise spatial data
9. Use different fonts
10. Work with extension packages 

* patchwork
* ggtext
* ggrepel
* ggbeeswarm
* ggblend
* gghighlight
* ggdensity
* ggridges
* ggdist
* ggeasy
* plotly::ggplotly
* ggiraph
* gganimate

```{r setup}
library(dplyr)
library(stringr)
library(ggplot2)
library(ggblanket)
library(palmerpenguins)
library(patchwork)

penguins <- penguins |>
  mutate(sex = str_to_sentence(sex)) |>
  tidyr::drop_na(sex)
```

### 1. Use the ggblank function

The `ggblank` function is the most flexible function in ggblanket.

It provides access to the most aesthetics. It provides lots of flexibility to use ggblanket with ggplot2 layers and other extension packages. 

Remember the `gg_*` function builds the x and y scales based on the `data`, `stat`, `x`, and `y` in the `gg_*` function - but these can be adjusted using the `facet_scales`, `*_include` and `*_limits` arguments. The plot scales are constructed without knowledge of subsequent layers. 

So with `ggblank`, you _must_ include the ggplot2 stat in the `gg_blank` function where it deviates from `"identity"`. The stat must be a character, as stat functions are not supported.      

```{r}
penguins |>
  gg_blank(
    x = body_mass_g, 
    stat = "bin") +
  geom_histogram(col = pal_blue, fill = pal_blue, alpha = 0.9)
```

### 2. Work with non-default stats

Users can change the default stat. The ... argument provides access to the relevant `stat_*` function as well as the `geom_*` function. Note, the `gg_*` functions do not support using a stat that is a function - it must be a character (e.g. "summary").  

```{r, fig.asp=0.5}
penguins |>
  gg_errorbar(
    x = body_mass_g,
    y = species,
    stat = "summary",
    fun.data = \(x) mean_se(x, 1.96),
    width = 0.25,
    x_include = 0
  ) +
  geom_bar(
    stat = "summary",
    fun = \(x) mean(x),
    alpha = 0.2,
    width = 0.75)
```

### 3. Use non-supported ggplot2 aesthetics

While aesthetics other than colouring are not supported by ggblanket, it is possible to access these in plots made with a combination of `gg_blank` and other ggplot2 code.

_Discrete non-col aesthetic_
```{r}
penguins |>
  gg_blank(
    x = bill_length_mm,
    y = body_mass_g, 
    col = sex) + #hack to enable ggblanket legend placement
  geom_point(aes(shape = sex), col = "#2B6999") + 
  labs(shape = "Sex") #name must be the same as the col_title
```

```{r}
penguins |>
  gg_blank(
    x = bill_length_mm,
    y = body_mass_g, 
    col = sex) + 
  geom_point(aes(shape = sex)) +  
  labs(shape = "Sex") #name must be the same as the col_title 
```

_Continuous non-col aesthetic_
```{r, fig.asp=0.5}
#legend on right
penguins |>
  gg_blank(
    x = bill_length_mm,
    y = body_mass_g) +  
  geom_point(aes(alpha = bill_depth_mm), col = "#2B6999") +
  labs(alpha = "Bill depth mm")
```

```{r}
#legend on bottom
penguins |>
  gg_blank(
    x = bill_length_mm,
    y = body_mass_g, 
    col = bill_depth_mm, #hack for ggblanket legend placement
    col_legend_place = "b") + #hack for ggblanket legend placement 
  geom_point(aes(alpha = bill_depth_mm), col = "#2B6999") +
  labs(alpha = "Bill depth mm") +
  guides(alpha = guide_legend(title.position = "top"))
```

```{r, fig.asp=0.5}
penguins |>
  gg_blank(
    x = bill_length_mm,
    y = body_mass_g, 
    col = species,
    col_legend_place = "r", #two legends look better on right
    col_title = "\nSpecies") + #hack to add space between legends
  geom_point(aes(alpha = bill_depth_mm)) +
  labs(alpha = "Bill depth mm") #name must be the same as the col_title
```

### 4. Use non-supported arguments

The `gg_*` function provides access to all arguments within the `geom_*` function other than the `mapping` argument. It also provides access to most of the useful arguments you might need in the various guide, scale and facet functions etc. However, it does not provide all such arguments. For example, the switch argument within `facet_grid` is not supported. A way to access this functionality is to `+` the `facet_grid(..., switch = "y")` in.

```{r}
penguins |>
  gg_point(
    x = flipper_length_mm, 
    y = body_mass_g,
    col = island,
    facet = species, 
    facet2 = sex,
    y_labels = \(x) glue::glue(" {x}")) + #hack to add space
  facet_grid(cols = vars(species),
             rows = vars(sex), 
             switch = "y")
```

### 5. Use non-supported geoms

gblanket does not support _all_ ggplot2 geoms. However, some of these can be accessed via the `gg_blank` function.

```{r, fig.asp=1}
p1 <- faithful |> 
  gg_blank(x = eruptions, 
           y = waiting, 
           x_breaks = scales::breaks_pretty(3), 
           subtitle = "geom_density_2d") + 
  geom_density2d(aes(col = after_stat(level)),
                 show.legend = FALSE)

p2 <- faithful |>
  gg_blank(x = waiting, 
           y = eruptions, 
           x_breaks = scales::breaks_pretty(3), 
           subtitle = "geom_density_2d_filled") + 
  geom_density_2d_filled(show.legend = FALSE)

p3 <- faithfuld |> 
  gg_blank(x = waiting, 
           y = eruptions, 
           x_breaks = scales::breaks_pretty(3), 
           subtitle = "geom_contour") + 
  geom_contour(aes(z = density, col = after_stat(level)),
               show.legend = FALSE) 

p4 <- faithfuld |> 
  gg_blank(x = waiting, 
           y = eruptions, 
           x_breaks = scales::breaks_pretty(3),
           subtitle = "geom_contour_filled") + 
  geom_contour_filled(aes(z = density), 
                      show.legend = FALSE)

(p1 + p2) / (p3 + p4)
```

### 6. Modifying a part of the colouring 

Where a `gg_*` function contains a geom that can colour both outlines and fill, users can turn off a part of this using the `alpha = 0` or `pal = scales::alpha("red", 0)`. 

If `col` is not NULL, then you can use `col = NA`, `fill = NA`, `col = "red"` or `fill = "red"` to modify a part of the colouring. But _not_ if col is NULL. In this case, you _must_ use `gg_blank`.

```{r, fig.asp=1}
p1 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = Species, 
    alpha = 0, 
    col_legend_nrow = 2, 
    col_labels = str_to_sentence)

p2 <- iris |>
  gg_density(
    x = Sepal.Length,
    alpha = 0)

p3 <- iris |>
  gg_density(
    x = Sepal.Length, 
    col = Species,
    pal = scales::alpha(pal_hue, 0), 
    col_legend_nrow = 2, 
    col_labels = str_to_sentence)

p4 <- iris |>
  gg_density(
    x = Sepal.Length,
    pal = scales::alpha(pal_blue, 0))

(p1 + p2) / (p3 + p4) 
```

### 7. Create custom wrapper functions

You can create powerful custom functions. This is because the `...` argument can allow you to access _all_  arguments within the ggblanket `gg_*` function (and applicable `ggplot2::geom_*` function). 

```{r}
gg_point_custom <- function(data, x, y, col, 
                            size = 3, 
                            shape = 17,
                            pal = RColorBrewer::brewer.pal(8, "Dark2"), 
                            col_title = "", 
                            col_legend_place = "t",
                            ...) {
  data |> 
    gg_point(x = {{ x }}, y = {{ y }}, col = {{col}}, 
             size = size, 
             shape = shape,
             pal = pal, 
             col_title = col_title, 
             col_legend_place = col_legend_place, 
             col_labels = str_to_sentence,
             ...)
}

iris |>
  gg_point_custom(
    x = Sepal.Width,
    y = Sepal.Length,
    col = Species)
```

### 8. Visualise spatial data

As ggblanket wraps the `ggplot2::geom_sf` and `ggplot2::geom_raster` functions, spatial vector and array data can be visualised. 

```{r}
sf::st_read(system.file("shape/nc.shp", package = "sf"), 
                  quiet = TRUE) |>
  gg_sf(col = AREA,
        pal = RColorBrewer::brewer.pal(9, "Blues"))
```

```{r}
stars::read_stars(system.file("tif/L7_ETMs.tif", package = "stars")) |>
 tibble::as_tibble() |>
 gg_raster(x = x,
           y = y,
           col = L7_ETMs.tif,
           facet = band,
           col_title = "",
           theme = light_mode())
```

### 9. Use different fonts

The showtext and sysfonts packages support the use of different fonts from google. The `theme_*_mode` functions provide `base_family`, `title_family`, `subtitle_family` and `caption_family` arguments. Fonts can be identified on the Google fonts [website](https://fonts.google.com/).

```{r, fig.asp = 0.75, fig.showtext = TRUE}
sysfonts::font_add_google("Covered By Your Grace", "grace")
showtext::showtext_auto(enable = TRUE)

penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex,
    facet = species,
    title = "Penguins body mass by flipper length",
    subtitle = "Palmer Archipelago, Antarctica",
    caption = "Source: Gorman, 2020",
    theme = light_mode(base_family = "grace", base_size = 12))

showtext::showtext_auto(enable = FALSE)
```

### 10. Work with extension packages

ggblanket can work with numerous extension packages. 

#### patchwork

The patchwork package enables plots to be patched together.

```{r}
set.seed(123)

p1 <- penguins |>
  gg_jitter(
    x = species,
    y = body_mass_g,
    col = sex, 
    pal = pal_hue[1:2],
    col_legend_ncol = 2,
    col_legend_nrow = 2)

p2 <- penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = species, 
    pal = pal_hue[3:5],
    y_title = "", 
    y_labels = \(x) str_sub(x, 0, 0), 
    col_legend_ncol = 2,
    col_legend_nrow = 2)

p1 + p2 
```

#### ggtext

The ggtext package enables plot text to use markdown syntax. The applicable markdown theme elements need to be added to the plot.

Note if you want to have some or all of a title not bold, then it's important to change the default theme have a plain title - as otherwise the `gg_theme` defaults to bold. 

```{r}
penguins |>
  gg_blank(
    x = flipper_length_mm, 
    y = body_mass_g,
    title = "**Bold** or _italics_ or <span style = 'color:red;'>red</span>",
    theme = light_mode(title_face = "plain")
    ) +
  theme(plot.title = ggtext::element_markdown())
```

```{r, fig.asp=0.75}
penguins |>
  gg_point(
    x = bill_length_mm,
    y = bill_depth_mm,
    col = species,
    facet = island,
    facet2 = sex,
    x_title = "**Bill length** (mm)", 
    y_title = "**Bill depth** (mm)",
    col_title = "**Species**",
    title = "***Pygoscelis*** **penguin** bill lengths and depths",
    subtitle = "<span style = 'color: #53B0AE ;'>**Adelie**</span>, 
       <span style = 'color:#A31414;'>**Chinstrap**</span>, 
       *and* <span style = 'color:#B2C615;'>**Gentoo**</span>", 
    x_labels = \(x) glue::glue("_{x}_"),
    y_labels = \(x) glue::glue("_{x}_"),
    col_labels = \(x) glue::glue("_{x}_"),
    facet_labels = \(x) glue::glue("_{x}_"),
    theme = light_mode(title_face = "plain")
  ) +
  theme(  
    plot.title = ggtext::element_markdown(),
    plot.subtitle = ggtext::element_markdown(),
    axis.title.x = ggtext::element_markdown(), 
    axis.title.y = ggtext::element_markdown(), 
    axis.text.x = ggtext::element_markdown(), 
    axis.text.y = ggtext::element_markdown(),
    legend.title = ggtext::element_markdown(),
    legend.text = ggtext::element_markdown(), 
    strip.text.x = ggtext::element_markdown(),
    strip.text.y = ggtext::element_markdown())
```

#### ggbeeswarm

The ggbeeswarm package can be used to create scatter plots that avoid overlapping points.

```{r}
penguins |> 
  gg_blank(x = species, 
           y = body_mass_g) + 
  ggbeeswarm::geom_quasirandom(col = pal_blue)
```

#### ggblend
 
The ggblend package provides blending of colours. 
 
```{r}
penguins |>
  gg_blank(
    x = flipper_length_mm,
    col = species,
    pal = RColorBrewer::brewer.pal(9, "Set1"),
    stat = "density") +
  geom_density(alpha = 0.5) |> ggblend::blend("multiply")
```

#### gghighlight

The gghighlight package enables geoms or parts thereof to be highlighted. 

It should be noted that the `gg_*` function builds the scale for the data that it thinks will be within the panel. Therefore in some situations, you will _need_ to add a `*_limits = c(NA, NA)` argument to make sure that the scale builds to include the full height of the non-highlighted data. 

```{r}
penguins |>
  gg_point(x = flipper_length_mm,
           y = body_mass_g) +
  gghighlight::gghighlight(body_mass_g >= 5000)
```

```{r}
iris |>
  gg_histogram(
    x = Sepal.Length,
    col = Species,
    facet = Species,
    facet_labels = str_to_sentence,
    pal = rep(pal_blue, 3),
    y_limits = c(NA, NA)
  ) +
  gghighlight::gghighlight()
```

#### ggdensity

The ggdensity package provides visualizations of density estimates.  

```{r}
iris |>
  mutate(Species = str_to_sentence(Species)) |> 
  gg_blank(
    x = Sepal.Width,
    y = Sepal.Length,
    col = Species,
    facet = Species,
    col_legend_place = "r", #two legends look better on right
    col_title = "\nSpecies") + #hack to add space between legends
  ggdensity::geom_hdr(col = NA) +
  labs(alpha = "Probs")
```

#### ggridges

The ggridges package enables ridgeline plots. 

```{r}
ggridges::Catalan_elections |>
  rename_with(snakecase::to_snake_case) |> 
  mutate(year = factor(year)) |>
  gg_blank(
    y = year, 
    x = percent, 
    col = option, 
    y_expand = c(0, 0), 
    col_title = "",
    col_legend_rev = TRUE, 
    pal = pal_hue[c(3, 1)]) +
  ggridges::geom_density_ridges(
    alpha = 0.8, 
    col = "white")
```

#### ggdist

The ggdist package enables the visualisation of uncertainty. The key to making this work with ggblanket is ensuring that `gg_blank` builds the distribution scale correctly. You can hack this by adding `*min` and `*max` aesthetics of a very low and very high quantile of the distributions. However, it might be easier to just use ggplot2 here. 

```{r}
library(distributional)

d <- data.frame(
  name = c("Gamma(2,1)", "Normal(5,1)", "Mixture"),
  dist = c(
    dist_gamma(2, 1),
    dist_normal(5, 1),
    dist_mixture(
      dist_gamma(2, 1), 
      dist_normal(5, 1), 
      weights = c(0.4, 0.6))
  )) 

d |>
  mutate(dist_min = quantile(dist, 0.001), 
         dist_max = quantile(dist, 0.999)) |> #to get scales functionally
  gg_blank(
    y = name, 
    xmin = dist_min, xmax = dist_max, #to get scales functionally
    y_expand = c(0.05, 0.05),
    y_title = "") +
  ggdist::stat_slabinterval(
    aes(dist = dist),
    col = pal_blue,
    fill = scales::alpha(pal_blue, 0.5))
```

```{r}
d <- tibble(x = 1:10,
       sd = seq(1, 3, length.out = 10)) |>
  mutate(dist = distributional::dist_normal(x, sd)) 

d |>
  mutate(dist_min = quantile(dist, 0.001), 
         dist_max = quantile(dist, 0.999)) |> #to get scales functionally
  gg_blank(
    x = x,
    ymin = dist_min, ymax = dist_max) + #to get scales functionally
  ggdist::stat_lineribbon(aes(ydist = dist)) +
  scale_fill_brewer() +
  labs(fill = "Level")
```

#### ggeasy

The ggeasy package provides a lot of support for easily modifying themes. 

```{r}
penguins |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex) +
  ggeasy::easy_remove_axes() 
  # theme(plot.margin = ggplot2::margin(t = 15, r = 17.5, b = 7.5, l = 15))
```

#### plotly::ggplotly

The plotly::ggplotly function enables interactive plots.

```{r, out.width=500, out.height=300}
p <- diamonds |>
  gg_bar(
    x = color,
    col = color,
    width = 0.75,
    theme = light_mode(base_family = "helvetica")) 

plotly::ggplotly(p, 
  tooltip = c("x", "y"), 
  width = 500, 
  height = 300)
```

#### ggiraph

The ggiraph package enables interactive plots.

```{r}
p <- diamonds |>
  gg_blank(
    x = color,
    col = color,
    width = 0.75,
    y_include = 0,
    stat = "count", 
    theme = light_mode(base_family = "helvetica", base_size = 9)) +
  ggiraph::geom_bar_interactive(
    aes(tooltip = after_stat(count), 
        data_id = color), width = 0.75)

ggiraph::girafe(
  ggobj = p, 
  height_svg = 3, 
  width_svg = 5,
  options = list(
    ggiraph::opts_sizing(rescale = TRUE, width = 0.7),
    ggiraph::opts_tooltip(use_fill = TRUE), 
    ggiraph::opts_hover(css = "stroke:black;stroke-width:1px;")))
```

#### gganimate

The gganimate package enables animated plots.

```{r, eval=FALSE}
gapminder::gapminder |> 
  gg_blank(
    x = gdpPercap, 
    y = lifeExp, 
    col = country, 
    facet = continent, 
    x_trans = "log10", 
    pal = gapminder::country_colors,
    col_legend_place = "n", 
    title = "Year: {frame_time}", 
    x_title = "GDP per capita", 
    y_title = "Life expectancy", 
    y_include = 0) +
  geom_point(aes(size = pop), alpha = 0.7) +
  scale_size(range = c(2, 12)) +
  gganimate::transition_time(year) +
  gganimate::ease_aes("linear")
```
```{r, echo=FALSE}
knitr::include_graphics("gganimate.gif")
```

