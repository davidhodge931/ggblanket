---
title: "Go further"
author: "David Hodge"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.6,
  out.width = "70%",
  dpi = 300
  )
```

## Overview

This article will demonstrate more advanced content, including how to: 

1. Reorder and/or reverse categorical variables
2. Drop unused categorical variable values
3. Fix either the colour outline or interior fill to a constant colour
4. Use `+ *_mode_*` where we axis-lines and gridlines are not correct
5. Use `replace_seq` to keep every nth label 
6. Transform scales
7. Add contrasting dark or light text on polygons
8. Centre a diverging colour scale 
9. Change the `stat`
10. Use opacity with to emphasise/demphasise. 
11. Use character inputs of variables 
12. Make custom wrapper functions of `gg_*` wrapper functions
13. Use delayed evaluation
14. Understand `oob` & `clip`

```{r setup}
library(ggblanket)
library(ggplot2)
library(dplyr)
library(stringr)
library(tidyr)
library(palmerpenguins)
library(patchwork)
```

### 1. Reorder and/or reverse categorical variables

ggblanket requires unquoted variables only for `x`, `y`, `col`, `facet`, `facet2` and  `alpha`. You can often manipulate the data prior to plotting to acheive what you want (e.g. using `tidyr::drop_na`, `forcats::fct_rev` and/or `forcats::fct_reorder`).

```{r}
p1 <- diamonds |>
  count(color) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nDefault order"
  )

p2 <- diamonds |>
  count(color) |>
  mutate(across(color, \(x) x |>
                  forcats::fct_reorder(n) |>
                  forcats::fct_rev())) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nRe-orderered"
  )

p1 + p2
```

### 2. Drop unused categorical variable values

ggblanket keeps unused factor levels in the plot. If users wish to drop unused levels they should likewise do it in the data prior to plotting using `forcats::fct_drop`. 

```{r}
p1 <- diamonds |> 
  count(color) |>
  filter(color %in% c("E", "G", "I")) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nUnused levels kept",
  )

p2 <- diamonds |> 
  count(color) |>
  filter(color %in% c("E", "G", "I")) |>
  mutate(color = forcats::fct_drop(color)) |> 
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nUnused levels dropped",
  )

p1 + p2
```

### 3. Fix either the colour outline or interior fill to a constant colour

For geom's that have both outline colour and interior fill, it is possible to fix one of these to a constant colour.

To do this, use `colour = "black"` or `fill = "#D3D3D3"`. Note this requires a `col` aesthetic to work. So you must do this in a hacky way, where you do not want a `col` aesthetic.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |>
  gg_boxplot(
    x = species,
    y = flipper_length_mm,
    col = sex,
    colour = "black", #or fill = #D3D3D3",
    position = position_dodge2(preserve = "single"),
    alpha_pal = 0.9,
  )
```

```{r}
penguins |>
  mutate(hack = "") |> 
  gg_boxplot(
    x = species,
    y = flipper_length_mm,
    col = hack,
    colour = "black", #or fill = #D3D3D3", 
    width = 0.5,
    alpha_pal = 0.9,
    mode = light_mode_n(),
  ) 
```

### 4. Use `+ *_mode_*` where we axis-lines and gridlines are not correct

Sometimes the plot might guess the removal of gridlines and axis-line/ticks incorrectly. In these situations, you can `+ *_mode_*` on to the plot, and then remove whatever you want. 

```{r}
data.frame(
  age = c(0:9, 0:9),
  sex = c(rep("Male", 10), rep("Female", 10)),
  population = c(200, 250, 300, 350, 440, 450, 500, 550, 600, 650,
                 190, 240, 290, 330, 420, 430, 480, 530, 580, 630)) |> 
  mutate(population = ifelse(sex == "Female", -population, population)) %>%
  gg_col(
    y = age,
    x = population,
    col = sex,
    width = 1,
    orientation = "y",
    x_labels = \(x) abs(x),
    x_include = max(abs(.$population)) * c(-1, 1),
    y_limits = c(NA, NA),
  ) +
  geom_vline(
    xintercept = 0,
    colour = lightness[1],
    linewidth = 10 / 33
  )
```

```{r}
data.frame(
  age = c(0:9, 0:9),
  sex = c(rep("Male", 10), rep("Female", 10)),
  population = c(200, 250, 300, 350, 440, 450, 500, 550, 600, 650,
                 190, 240, 290, 330, 420, 430, 480, 530, 580, 630)) |> 
  mutate(population = ifelse(sex == "Female", -population, population)) %>%
  gg_col(
    y = age,
    x = population,
    col = sex,
    width = 1,
    orientation = "y",
    x_labels = \(x) abs(x),
    x_include = max(abs(.$population)) * c(-1, 1),
    y_limits = c(NA, NA),
  ) +
  geom_vline(
    xintercept = 0,
    colour = lightness[1],
    linewidth = 10 / 33
  ) +
  light_mode_r() +
  ggeasy::easy_remove_y_gridlines() +
  ggeasy::easy_remove_y_axis()

```

### 5. Use `replace_seq` to keep every nth label 

A `replace_seq` helper function is provided to replace a sequence of labels with `""`. This can be particularly useful when faceting.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_freqpoly(
    x = flipper_length_mm,
    col = species,
    y_breaks = scales::breaks_pretty(7),
    y_labels = \(x) replace_seq(x), 
  )
```

### 6. Transform scales

Transform objects (e.g. `scales::transform_log()` or character strings of these can be used to transform scales - including combining these.

```{r, fig.asp=0.75}
p1 <- pressure |>
  gg_point(
    x = temperature, 
    y = pressure, 
    x_labels = replace_seq,
    y_labels = replace_seq,
    subtitle = "\nDefault",
  )

p2 <- pressure |>
  gg_point(
    x = temperature, 
    y = pressure, 
    x_labels = replace_seq,
    y_transform = "reverse", 
    y_labels = replace_seq,
    subtitle = "\nReverse",
  )

p3 <- pressure |>
  gg_point(
    x = temperature, 
    y = pressure,
    x_labels = replace_seq,
    y_transform = "log10",
    subtitle = "\nLog10", 
  )

p4 <- pressure |>
  gg_point(
    x = temperature, 
    y = pressure, 
    x_labels = replace_seq,
    y_transform = c("log10", "reverse"),
    subtitle = "\nLog10 & Reverse",
  )

(p1 + p2) / (p3 + p4)
```

### 7. Add contrasting dark or light text on polygons

Text on polygons can be coloured with a dark or light colour that is determined based on the underlying polygon colour using `!!!aes_contrast()`. This method was developed by Teun van den Brand (@teunbrand). The `lightness`, `greyness` and `darkness` colour vectors work nicely with the applicable `*_mode_*` theme. 

```{r}
penguins |>
  count(species, sex) |>
  gg_col(
    x = sex,
    y = n,
    col = species,
    position = position_dodge2(preserve = "single"),
    width = 0.75,
    x_labels = \(x) str_to_sentence(x),
  ) +
  geom_text(
    mapping = aes(y = n - (max(n * 0.04)), label = n, 
                  !!!aes_contrast(lightness)),
    position = position_dodge2(width = 0.75, preserve = "single"),
    show.legend = FALSE,
  ) 
```

```{r}
penguins |>
  count(species, sex) |>
  gg_col(
    x = sex,
    y = n,
    col = species,
    position = position_dodge2(preserve = "single"),
    width = 0.75,
    x_labels = \(x) str_to_sentence(x),
    mode = dark_mode_r(),
  ) +
  geom_text(
    mapping = aes(y = n - (max(n * 0.04)), label = n, 
                  !!!aes_contrast(darkness)),
    position = position_dodge2(width = 0.75, preserve = "single"),
    show.legend = FALSE,
  ) 
```

### 8. Centre a diverging colour scale 

Sometimes you need to centre a diverging colour scale.

```{r}
mpg |>
  mutate(centred = cty - mean(cty)) |>
  select(displ, hwy, centred) %>%
  gg_point(
    x = displ,
    y = hwy,
    col = centred,
    col_pal = c(teal, greys[1], orange),
    col_breaks = scales::breaks_width(5),
    col_rescale = scales::rescale(c(min(.$centred), 0, max(.$centred)))
  )
```

```{r}
mpg |>
  mutate(centred = cty - mean(cty)) |>
  select(displ, hwy, centred) %>%
  gg_point(
    x = displ,
    y = hwy,
    col = centred,
    col_pal = c(teal, greys[1], orange),
    col_limits = max(abs(.$centred)) * c(-1, 1),
    col_breaks = scales::breaks_width(5)
  )
```

### 9. Change the `stat`

The default `stat` of each `gg_*` function can be changed. 

```{r}
penguins |>
  gg_pointrange(
    stat = "summary", 
    x = species,
    y = flipper_length_mm, 
    size = 0.1,
  )
```

```{r}
library(ggforce)

ggplot2::economics |>
  slice_head(n = 35) |> 
  gg_path(
    stat = "bspline",
    x = date, 
    y = unemploy,
    n = 100, 
    linewidth = 1,
  ) 
```

### 10. Use opacity to emphasise/demphasise 

Use opacity with `alpha`, `col`, and `alpha_pal/col_pal` to emphasise/demphasise parts of the visualisation. 

```{r, fig.asp=0.75}
p1 <- penguins |> 
  drop_na(sex) |> 
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_density(
    x = flipper_length_mm,
    x_breaks = scales::breaks_pretty(n = 3),
    col_pal = scales::alpha(orange, 0.33),
    alpha_pal = 0.1,
    subtitle = "\ninteriour fill with opacity 0.1 & outline 0.33"
  )

p2 <- penguins |> 
  drop_na(sex) |> 
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_density(
    x = flipper_length_mm,
    col = sex,
    x_breaks = scales::breaks_pretty(n = 3),
    col_pal = c(orange, "#78909C"),
    subtitle = "\ncol variable"
  )

p3 <- penguins |> 
  drop_na(sex) |> 
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_density(
    x = flipper_length_mm,
    col = sex, 
    alpha = sex,
    x_breaks = scales::breaks_pretty(n = 3),
    col_pal = c(orange, "#78909C"),
    alpha_pal = c(0.5, 0.1),
    subtitle = "\ncol and alpha variable",
  ) +
  guides(colour = "none", fill = "none", alpha = "none")

p4 <- penguins |> 
  drop_na(sex) |> 
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_density(
    x = flipper_length_mm,
    col = sex, 
    alpha = sex,
    x_breaks = scales::breaks_pretty(n = 3),
    col_pal = c(orange, scales::alpha("#78909C", 0.25)),
    alpha_pal = c(0.5, 0.1),
    subtitle = "\ncol and alpha variable & outline opacity",
  )

(p1 + p2) / (p3 + p4)
```

### 11. Use character inputs of variables

It can be useful in shiny apps to use character inputs of variables. This can be done using `.data`.

```{r}
x <- "flipper_length_mm"
y <- "body_mass_g"

penguins |> 
  gg_point(
    x = .data[[x]],
    y = .data[[y]],
  )
```

### 12. Make custom wrapper functions of `gg_*` wrapper functions

You may wish to make your own wrapper functions if you are continually adding the same defaults to your `gg_*` functions. But remember `mode_set` and `ggplot2::theme_set` are available. 

```{r}
gg_point_custom <- function(data, 
                            x = NULL, 
                            y = NULL, 
                            col = NULL, 
                            facet = NULL,
                            ...) {
  
  data |> 
    gg_point(
      x = {{ x }},
      y = {{ y }},
      col = {{ col }},
      facet = {{ facet }},
      col_pal = RColorBrewer::brewer.pal(8, "Dark2"),
      y_breaks = scales::breaks_pretty(10),
      y_labels = replace_seq,
      shape = 17,
      size = 2, 
      mode = grey_mode_t(),
      ...,
    ) +
    theme(legend.title = element_blank())
}

p1 <- penguins |> 
  gg_point_custom(
    x = flipper_length_mm,
    y = body_mass_g,
  )

p2 <- penguins |> 
  gg_point_custom(
    x = flipper_length_mm,
    y = body_mass_g,
    col = species,
  )

p1 + p2
```

### 13. Use delayed evaluation

As the `x`, `y`, `col` and `alpha` aesthetic arguments require a unquoted variable, you cannot apply a function to these. However, you can for aesthetics within the `mapping` argument. This can be used for delayed evaluation with the `ggplot2::after_stat` function.

```{r, fig.asp=0.55}
penguins |>
  gg_histogram(
    x = flipper_length_mm,
    mapping = aes(y = after_stat(density)),
    facet = species,
  )
```

```{r, fig.asp=0.55}
faithfuld |>
  gg_contour(
    x = waiting,
    y = eruptions,
    z = density,
    mapping = aes(colour = after_stat(level)),
    bins = 8,
  )
```

### 14. Understand `oob` & `clip`

By default, ggblanket keeps values outside of the limits (`*_oob = scales::oob_keep`) in calculating the geoms and scales to plot. It also does _not_ clip anything outside the cartesian coordinate space by default (`coord = ggplot2::coord_cartesian(clip = "off"`)). 

ggplot2 by default drops values outside of the limits in calculating the geoms and scales to plot (`scales::oob_censor`), and clips anything outside the cartesian coordinate space (`coord = ggplot2::coord_cartesian(clip = "on"`)).

This needs to be considered particularly when you are using `x_limits` or `y_limits`, and your `stat` is _not_ `"identity"`.  

```{r}
p1 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    subtitle = "\nNo x_limits set", 
    se = TRUE) +
  geom_vline(xintercept = c(lubridate::ymd("1985-01-01", "1995-01-01")),
             col = blue, 
             linetype = 3) +
  geom_point(col = blue, alpha = 0.3)

p2 <- economics |> 
  filter(between(date, lubridate::ymd("1985-01-01"), lubridate::ymd("1995-01-01"))) |> 
  gg_smooth(
    x = date, 
    y = unemploy,
    se = TRUE,
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    subtitle = "\nx data filtered") +
  geom_point(col = blue, alpha = 0.3)

p1 + p2
```

```{r}
p3 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    subtitle = "\nx_limits set (with default oob_keep)", 
  ) +
  geom_point(col = blue, alpha = 0.3)

p3 + plot_spacer()
```

```{r}
p4 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    coord = coord_cartesian(clip = "on"), 
    subtitle = "\nx_limits set  (with default oob_keep)\n& cartesian space clipped") +
  geom_point(col = blue, alpha = 0.3)

p5 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    x_oob = scales::oob_censor,
    subtitle = "\nx_limits set & oob_censor") +
  geom_point(col = blue, alpha = 0.3)

p4 + p5
```



