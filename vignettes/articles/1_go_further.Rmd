---
title: "Go further"
author: "David Hodge"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.6,
  out.width = "70%",
  dpi = 300
  )
```

## Overview

This article will demonstrate more advanced content, including how to: 

1. Reorder and/or reverse categorical variables
2. Drop unused categorical variable values
3. Use different fonts
4. Visualise spatial data
5. Change the `stat`
6. Fix either the colour outline or interior fill to a constant colour
7. Use delayed evaluation
8. Add contrasting dark or light text on polygons
9. Understand `oob` & `clip

```{r setup}
library(ggblanket)
library(ggplot2)
library(dplyr)
library(stringr)
library(tidyr)
library(palmerpenguins)
library(patchwork)
```

### 1. Reorder and/or reverse categorical variables

ggblanket requires unquoted variables only for `x`, `y`, `col`, `facet`, `facet2` and  `alpha`. You can often manipulate the data prior to plotting to acheive what you want (e.g. using `tidyr::drop_na`, `forcats::fct_rev` and/or `forcats::fct_reorder`).

```{r}
p1 <- diamonds |>
  count(color) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nDefault order"
  )

p2 <- diamonds |>
  count(color) |>
  mutate(across(color, \(x) x |>
                  forcats::fct_reorder(n) |>
                  forcats::fct_rev())) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nRe-orderered"
  )

p1 + p2
```

### 2. Drop unused categorical variable values

ggblanket keeps unused factor levels in the plot. If users wish to drop unused levels they should likewise do it in the data prior to plotting using `forcats::fct_drop`. 

```{r}
p1 <- diamonds |> 
  count(color) |>
  filter(color %in% c("E", "G", "I")) |>
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nUnused levels kept",
  )

p2 <- diamonds |> 
  count(color) |>
  filter(color %in% c("E", "G", "I")) |>
  mutate(color = forcats::fct_drop(color)) |> 
  gg_col(
    x = n,
    y = color,
    width = 0.75,
    x_labels = \(x) x / 1000,
    x_title = "Count (thousands)", 
    subtitle = "\nUnused levels dropped",
  )

p1 + p2
```

### 3. Use different fonts

The showtext and sysfonts packages support the use of different fonts from Google. The `*_mode_*` theme functions provide a `base_family` argument.

```{r, fig.asp = 0.7, fig.showtext = TRUE}
head(sysfonts::font_families_google())

sysfonts::font_add_google("Covered By Your Grace", "grace")
sysfonts::font_add_google('Roboto Slab', 'roboto_slab')
sysfonts::font_add_google('Syne Mono', 'syne')

showtext::showtext_auto(enable = TRUE)

penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex,
    facet = species,
    title = "Penguins body mass by flipper length",
    subtitle = "Palmer Archipelago, Antarctica",
    caption = "Source: Gorman, 2020",
    mode = grey_mode_rt(base_size = 11, base_family = "grace")
  ) +
  theme(
    plot.title = element_text(family = "roboto_slab"),
    plot.subtitle = element_text(family = "syne")
  )

showtext::showtext_auto(enable = FALSE)
```

### 4. Visualise spatial data

As ggblanket wraps the `ggplot2::geom_sf` and `ggplot2::geom_raster` functions, spatial vector and array data can be visualised. 

```{r, fig.asp=0.4}
sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE) |>
  gg_sf(col = AREA) 
```

```{r}
stars::read_stars(system.file("tif/L7_ETMs.tif", package = "stars")) |>
 tibble::as_tibble() |>
 gg_raster(
   x = x,
   y = y,
   col = L7_ETMs.tif,
   facet = band,
   col_title = "L7 ETMs",
  ) +
  ggeasy::easy_remove_x_axis() +
  ggeasy::easy_remove_y_axis() 
```

### 5. Change the `stat`

The default `stat` of each `gg_*` function can be changed. 

```{r}
penguins |>
  gg_pointrange(
    stat = "summary", 
    x = species,
    y = flipper_length_mm, 
    size = 0.1,
  )
```

```{r}
library(ggforce)

ggplot2::economics |>
  slice_head(n = 35) |> 
  gg_path(
    stat = "bspline",
    x = date, 
    y = unemploy,
    n = 100, 
    linewidth = 1,
  ) 
```

### 6. Fix either the colour outline or interior fill to a constant colour

For geom's that have both outline colour and interior fill, it is possible to fix one of these to a constant colour.

To do this, use `colour = "black"` or `fill = "#D3D3D3"`. Note this requires a `col` aesthetic to work. So you must do this in a hacky way, where you do not want a `col` aesthetic.

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |>
  gg_boxplot(
    x = species,
    y = flipper_length_mm,
    col = sex,
    colour = "black", #or fill = #D3D3D3",
    position = position_dodge2(preserve = "single"),
    alpha_pal = 0.9,
  )
```

```{r}
penguins |>
  mutate(hack = "") |> 
  gg_boxplot(
    x = species,
    y = flipper_length_mm,
    col = hack,
    colour = "black", #or fill = #D3D3D3", 
    width = 0.5,
    alpha_pal = 0.9,
    mode = grey_mode_n(),
  ) 
```

### 7. Use delayed evaluation

As the `x`, `y`, `col` and `alpha` aesthetic arguments require a unquoted variable, you cannot apply a function to these. However, you can for aesthetics within the `mapping` argument. This can be used for delayed evaluation with the `ggplot2::after_stat` function.

```{r, fig.asp=0.55}
penguins |>
  gg_histogram(
    x = flipper_length_mm,
    mapping = aes(y = after_stat(density)),
    facet = species,
  )
```

```{r, fig.asp=0.55}
faithfuld |>
  gg_contour(
    x = waiting,
    y = eruptions,
    z = density,
    mapping = aes(colour = after_stat(level)),
    bins = 8,
  )
```

### 8. Add contrasting dark or light text on polygons

Text on polygons can be coloured with a dark or light colour that is determined based on the underlying polygon colour using `!!!aes_contrast()`. This method was developed by Teun van den Brand (@teunbrand).

```{r}
penguins |>
  count(species, sex) |>
  gg_col(
    x = sex,
    y = n,
    col = species,
    position = position_dodge2(preserve = "single"),
    width = 0.75,
    x_labels = \(x) str_to_sentence(x),
  ) +
  geom_text(
    mapping = aes(y = n - (max(n * 0.04)), label = n, 
                  !!!aes_contrast(lightness)),
    position = position_dodge2(width = 0.75, preserve = "single"),
    show.legend = FALSE,
  ) 
```

```{r}
penguins |>
  count(species, sex) |>
  gg_col(
    x = sex,
    y = n,
    col = species,
    position = position_dodge2(preserve = "single"),
    width = 0.75,
    x_labels = \(x) str_to_sentence(x),
    mode = grey_mode_rt(),
  ) +
  geom_text(
    mapping = aes(y = n - (max(n * 0.04)), label = n, 
                  !!!aes_contrast(greyness)),
    position = position_dodge2(width = 0.75, preserve = "single"),
    show.legend = FALSE,
  ) 
```

```{r}
penguins |>
  count(species, sex) |>
  gg_col(
    x = sex,
    y = n,
    col = species,
    position = position_dodge2(preserve = "single"),
    width = 0.75,
    x_labels = \(x) str_to_sentence(x),
    mode = dark_mode_rt(),
  ) +
  geom_text(
    mapping = aes(y = n - (max(n * 0.04)), label = n, 
                  !!!aes_contrast(darkness)),
    position = position_dodge2(width = 0.75, preserve = "single"),
    show.legend = FALSE,
  ) 
```

### 9. Understand `oob` & `clip`

By default, ggblanket keeps values outside of the limits (`*_oob = scales::oob_keep`) in calculating the geoms and scales to plot. It also does _not_ clip anything outside the cartesian coordinate space by default (`coord = ggplot2::coord_cartesian(clip = "off"`)). 

ggplot2 by default drops values outside of the limits in calculating the geoms and scales to plot (`scales::oob_censor`), and clips anything outside the cartesian coordinate space (`coord = ggplot2::coord_cartesian(clip = "on"`)).

This needs to be considered particularly when you are using `x_limits` or `y_limits`, and your `stat` is _not_ `"identity"`.  

```{r}
p1 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    subtitle = "\nNo x_limits set", 
    se = TRUE) +
  geom_vline(xintercept = c(lubridate::ymd("1985-01-01", "1995-01-01")),
             col = blue, 
             linetype = 3) +
  geom_point(col = blue, alpha = 0.3)

p2 <- economics |> 
  filter(between(date, lubridate::ymd("1985-01-01"), lubridate::ymd("1995-01-01"))) |> 
  gg_smooth(
    x = date, 
    y = unemploy,
    se = TRUE,
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    subtitle = "\nx data filtered") +
  geom_point(col = blue, alpha = 0.3)

p1 + p2
```

```{r}
economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    subtitle = "\nx_limits set", 
  ) +
  geom_point(col = blue, alpha = 0.3) 
```

```{r}
p4 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    coord = coord_cartesian(clip = "on"), 
    subtitle = "\nx_limits set & cartesian space clipped") +
  geom_point(col = blue, alpha = 0.3)

p5 <- economics |> 
  gg_smooth(
    x = date, 
    y = unemploy, 
    se = TRUE,
    x_limits = c(lubridate::ymd("1985-01-01", "1995-01-01")),
    x_labels = \(x) stringr::str_sub(x, 3, 4),
    x_oob = scales::oob_censor,
    subtitle = "\nx_limits set & x_oob censored") +
  geom_point(col = blue, alpha = 0.3)


p4 + p5
```

### 10. Use `replace_seq` to label only every nth break

A `replace_seq` helper function is provided to replace a sequence of labels with `""`. 

```{r}
penguins |>
  mutate(across(sex, \(x) str_to_sentence(x))) |> 
  gg_histogram(
    x = flipper_length_mm,
    facet = species,
    facet2 = sex,
    y_breaks = scales::breaks_pretty(7),
    y_labels = \(x) replace_seq(x), 
  )
```

