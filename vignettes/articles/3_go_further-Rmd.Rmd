---
title: "Go further"
author: "David Hodge"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "70%",
  dpi = 300
  )
```

## Overview

This article will demonstrate more advanced content, including how to: 

1. Use different fonts
2. Visualise spatial data
3. Turn off either colour or fill
4. Fix either colour or fill to something different 
5. Work with other aesthetics (or delayed evaluation)
6. Change the stat
7. Create custom wrapper functions
8. Add auto-contrast text on polygons 


```{r setup}
library(dplyr)
library(stringr)
library(ggplot2)
library(ggblanket)
library(patchwork)

penguins2 <- palmerpenguins::penguins |>
  mutate(sex = stringr::str_to_sentence(sex)) |>
  tidyr::drop_na(sex)
```

### 1. Use different fonts

The showtext and sysfonts packages support the use of different fonts from Google. The `*_mode` theme functions provide `base_family`, `title_family`, `subtitle_family` and `caption_family` arguments. Fonts can be identified on the Google fonts [website](https://fonts.google.com/).

```{r, fig.asp = 0.75, fig.showtext = TRUE}
sysfonts::font_add_google("Covered By Your Grace", "grace")
sysfonts::font_add_google('Roboto Slab', 'roboto_slab')
sysfonts::font_add_google('Syne Mono', 'syne')

showtext::showtext_auto(enable = TRUE)

penguins2 |>
  gg_point(
    x = flipper_length_mm,
    y = body_mass_g,
    col = sex,
    facet = species,
    title = "Penguins body mass by flipper length",
    subtitle = "Palmer Archipelago, Antarctica",
    caption = "Source: Gorman, 2020",
    pal = c("#2596be", "#fc7c24"),
    theme = light_mode(
      base_size = 11,
      base_family = "grace", 
      title_family = "roboto_slab", 
      subtitle_family = "syne"))
showtext::showtext_auto(enable = FALSE)
```

### 2. Visualise spatial data

As ggblanket wraps the `ggplot2::geom_sf` and `ggplot2::geom_raster` functions, spatial vector and array data can be visualised. 

```{r, fig.asp=0.33}
sf::st_read(system.file("shape/nc.shp", package = "sf"), 
                  quiet = TRUE) |>
  gg_sf(col = AREA,
        pal = RColorBrewer::brewer.pal(9, "Blues")) +
  ggeasy::easy_remove_axes()
```

```{r}
stars::read_stars(system.file("tif/L7_ETMs.tif", package = "stars")) |>
 tibble::as_tibble() |>
 gg_raster(x = x,
           y = y,
           col = L7_ETMs.tif,
           facet = band,
           col_title = "") +
  ggeasy::easy_remove_axes()
```

### 3. Turn off either colour or fill 

Users can turn off _either_ the colour (i.e. of the outlines) or fill of a geom that contains both. A method is to use `alpha = 0` for the fill or `pal = scales::alpha("red", 0)` for the colour. 

```{r, fig.asp=1}
p1 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = Species, 
    alpha = 0, 
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_nrow = 2, 
    col_labels = \(x) str_to_sentence(x),
    title = "Turn off either colour or fill",
    theme = light_mode(title_face = "plain"))

p2 <- iris |>
  gg_density(
    x = Sepal.Length,
    alpha = 0,
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE))

p3 <- iris |>
  gg_density(
    x = Sepal.Length, 
    col = Species,
    pal = scales::alpha(jumble(), 0), 
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_nrow = 2, 
    col_labels = \(x) str_to_sentence(x))

p4 <- iris |>
  gg_density(
    x = Sepal.Length,
    pal = scales::alpha("steelblue", 0),
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE))

(p1 + p2) / (p3 + p4) 
```

### 4. Fix either colour or fill to something different 

Users can also fix _either_ the colour (i.e. of the outlines) or fill of a geom to something different than the `pal`. A method for where there is a `col` variable is to add a `colour = "black"` or `fill = "lightgrey"` argument. If no col variable is desired, just use `col = 1` and `col_legend_place = "n"`.

```{r, fig.asp=1}
p1 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = 1, 
    stat = "density", 
    pal = "steelblue",
    colour = "black",
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_place = "n", 
    title = "Fix a different colour or fill",
    theme = light_mode(title_face = "plain")) 

p2 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = 1, 
    stat = "density", 
    pal = "steelblue",
    fill = "lightgrey",
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_place = "n") 

p3 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = Species, 
    fill = "lightgrey",
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_nrow = 2, 
    col_labels = \(x) str_to_sentence(x))

p4 <- iris |>
  gg_density(
    x = Sepal.Length,
    col = Species, 
    colour = "black",
    y_labels = \(x) str_keep_seq(x, drop0trailing = TRUE),
    col_legend_nrow = 2, 
    col_labels = \(x) str_to_sentence(x))

(p1 + p2) / (p3 + p4) 
```

### 5. Work with other aesthetics (or delayed evaluation)

Most functions have the commonly needed aesthetics directly available as an argument.

For those that are not available (or where you wish to use delayed evaluation), you can either use `mapping` argument (for aesthetics other than colour, fill or alpha) or `gg_blank`.

The `mapping` argument provides access to the `linetype`, `shape` and `size` aesthetics within the `gg_*` function. Note the `col`, `colour`, `fill` and `alpha` aesthetics cannot be added within the ggblanket `mapping` argument. 

An alternative approach is to use `gg_blank`. If you use this approach, make sure you change the `stat`, `position`, and `coord` etc as needed in `gg_blank`, so that the positional scales are constructed correctly. Note the `stat` must be a character string.

```{r}
penguins2 |> 
  gg_point(x = flipper_length_mm, 
           y = body_mass_g, 
           col = species,
           mapping = aes(shape = species))
```

```{r, fig.asp=0.55}
penguins2 |>
  gg_histogram(x = flipper_length_mm,
               mapping = aes(y = after_stat(density)),
               facet = species)
```

```{r, fig.asp=0.55}
faithfuld |>
   gg_blank(
     x = waiting,
     y = eruptions,
     z = density,
     stat = "contour",
     bins = 8) +
   geom_contour(aes(colour = after_stat(level)), bins = 8) +
   labs(colour = "Level")
```

### 6. Change the stat

The default `stat` of each `gg_*` function can be changed for additional flexibility. Note that you can only use `stat` character strings and not functions.

```{r, fig.asp=0.7}
p1 <- penguins2 |>
  gg_pointrange(
    x = species,
    y = flipper_length_mm, 
    stat = "summary", 
    size = 0.1,
    x_labels = \(x) str_sub(x, 1, 1))

p2 <- penguins2 |>
  gg_bar(x = flipper_length_mm,
         stat = "bin", 
         x_labels = \(x) str_keep_seq(x))

p3 <- penguins2 |>
  gg_bar(
    x = flipper_length_mm,
    y = species,
    col = sex,
    stat = "summary", 
    position = "dodge",
    pal = c("#2596be", "#fc7c24"), 
    width = 0.75,
    col_legend_place = "r")

(p1 + p2) / p3
```

### 7. Create custom wrapper functions

You can create powerful custom functions. This is because the `...` argument can allow you to access _all_  arguments within the ggblanket `gg_*` function (and applicable `ggplot2::geom_*` function). 

```{r, fig.asp=1}
gg_point_custom <- function(data, x, y, col = NULL, facet = NULL, facet2 = NULL,
                            pal = RColorBrewer::brewer.pal(8, "Dark2"),
                            col_labels = \(x) stringr::str_to_sentence(x),
                            col_title = "", 
                            col_legend_place = "t",
                            ...) {
  data |> 
    gg_point(x = {{ x }}, y = {{ y }}, 
             col = {{ col }}, facet = {{ facet }}, facet2 = {{ facet2 }},
             pal = pal, col_labels = col_labels, col_title = col_title, 
             col_legend_place = col_legend_place, ...) +
    ggeasy::easy_remove_axes(which = "y", what = c("line", "ticks"))
}

p1 <- penguins2 |>
  gg_point_custom(
    x = flipper_length_mm,
    y = body_mass_g, 
    col = species)

p2 <- penguins2 |>
  gg_point_custom(
    x = flipper_length_mm,
    y = body_mass_g, 
    col = sex)

p1 / p2
```

### 8. Add auto-contrast text on polygons

Text labels can be coloured based on the lightness/darkness of underlying polygons using a trick documented by [@teunbrand](https://github.com/teunbrand/ggplot_tricks). It requires `geom_text` to include the `show.legend = FALSE` argument.   

```{r}
contrast <- function(colour) {
  out   <- rep("#121b24", length(colour)) #use "#bbccdd" for dark_mode
  light <- farver::get_channel(colour, "l", space = "hcl")
  out[light < 50] <- "#fcfdfe" #use "#1f2f3e" for dark_mode 
  out
}

p <- penguins2 |>
  group_by(sex, species) |>
  summarise(across(flipper_length_mm, \(x) mean(x, na.rm = TRUE))) |>
  gg_col(
    x = flipper_length_mm,
    y = species,
    col = sex,
    position = "dodge",
    width = 0.75) 

p +
  geom_text(
    aes(x = flipper_length_mm - (max(flipper_length_mm) * 0.05),
        label = round(flipper_length_mm, 0),
        !!!aes(colour = after_scale(contrast(fill)))), 
    show.legend = FALSE,
    size = 3.53, 
    position = position_dodge(width = 0.75))
```

```{r}
d <- mtcars |> 
  corrr::correlate() |> 
  corrr::stretch() |> 
  mutate(across(c(x, y), str_to_sentence))

d |> 
  gg_tile(
    x = x, 
    y = y,
    col = r,
    # pal = RColorBrewer::brewer.pal(9, "RdBu"),
    pal_na = "#e6ecf2",
    col_limits = c(-1, 1),
    col_rescale = scales::rescale(c(-1, 0, 1)),
    x_title = "", 
    y_title = "", 
    x_expand = c(0, 0), 
    y_expand = c(0, 0),
    col_title = "r") +
  geom_text(
    aes(label = round(r, 1),
        !!!aes(colour = after_scale(contrast(fill)))), 
    show.legend = FALSE,
    size = 3.53)
```
